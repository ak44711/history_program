/*完全平方数 
首先算出所有小于n的完全平方数按升序存放在数组a[]里面，假设有m个 

考虑到：
n一定是由一个小与n的数加上一个完全平方数得到的，我们需要是最少的完全平方数的数量
设置dp[n]表示得到n的最少数量，则dp[n]的递归方程建立为
dp[n] = min(dp[n - a[m]] + 1, dp[n - a[m-1]] + 1 .... )
		0, n = 0
		∞,n < 0 
发现其中有大量的重叠子问题，所以使用动态规划 
*/
int f(int n) {
	int a[N], m = 0;
	for(int i = 1; i * i <= n; i++) {
		a[m++] = i * i;
	}
	int dp[N];
	dp[0] = 0;
	for(int i = 1; i <= n; i++) {
		for(int j = m - 1; j >=0; j--) {
			if(i - a[j] >= 0) {
				dp[i] = min(dp[i], dp[i - a[j]] + 1);
			}
		}
	}
}

